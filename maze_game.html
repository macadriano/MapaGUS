<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego del Laberinto</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        .game-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .score {
            color: #4CAF50;
        }
        
        .time {
            color: #FF9800;
        }
        
        .moves {
            color: #2196F3;
        }
        
        canvas {
            border: 3px solid #333;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .new-game {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }
        
        .new-game:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        
        .instructions {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }
        
        .instructions:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            margin-top: -20px;
        }
        
        .close:hover {
            color: #000;
        }
        
        .victory {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 20px;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
                margin: 10px;
            }
            
            canvas {
                max-width: 100%;
                height: auto;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üèÉ‚Äç‚ôÇÔ∏è El Laberinto de Randall üèÉ‚Äç‚ôÄÔ∏è</h1>
        
        <div class="game-info">
            <div class="score">Puntuaci√≥n: <span id="score">0</span></div>
            <div class="time">Tiempo: <span id="time">00:00</span></div>
            <div class="moves">Movimientos: <span id="moves">0</span></div>
        </div>
        
        <div id="generating-indicator" style="display: none; color: #FF9800; font-weight: bold; margin-bottom: 10px;">
            üîÑ Generando laberinto...
        </div>
        
        <div id="seed-info" style="font-size: 12px; color: #888; margin-bottom: 10px;">
            üé≤ Semilla: <span id="current-seed">-</span>
        </div>
        
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <div class="controls">
            <button class="new-game" onclick="newGame()">üîÑ Nuevo Juego</button>
            <button class="instructions" onclick="showInstructions()">üìñ Instrucciones</button>
        </div>
        
        <div style="margin-top: 15px; font-size: 14px; color: #666;">
            üí° <strong>Garant√≠a:</strong> Siempre hay un camino v√°lido hasta la meta
        </div>
        
        <div style="margin-top: 10px; font-size: 12px; color: #888;">
            üé≤ <strong>Dificultad:</strong> Cada partida es √∫nica y desafiante
        </div>
    </div>

    <!-- Modal de Instrucciones -->
    <div id="instructionsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>üéÆ C√≥mo Jugar</h2>
            <div style="text-align: left; line-height: 1.6;">
                <p><strong>üéØ Objetivo:</strong> Lleva a Randall hasta la meta (üü¢) evitando las paredes del laberinto.</p>
                
                <p><strong>üéÆ Controles:</strong></p>
                <ul>
                    <li><strong>Teclas de flecha</strong> o <strong>WASD</strong> para mover el personaje</li>
                    <li><strong>Click en el canvas</strong> para mover hacia esa direcci√≥n</li>
                    <li><strong>Touch</strong> en dispositivos m√≥viles</li>
                </ul>
                
                <p><strong>‚≠ê Puntuaci√≥n:</strong></p>
                <ul>
                    <li>+100 puntos por completar el laberinto</li>
                    <li>+10 puntos por cada movimiento eficiente</li>
                    <li>Bonus de tiempo: m√°s r√°pido = m√°s puntos</li>
                </ul>
                
                <p><strong>üí° Consejos:</strong></p>
                <ul>
                    <li>Planifica tu ruta antes de moverte</li>
                    <li>Evita movimientos innecesarios</li>
                    <li>¬°Cada segundo cuenta!</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        class MazeGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.cellSize = 20;
                this.cols = Math.floor(this.canvas.width / this.cellSize);
                this.rows = Math.floor(this.canvas.height / this.cellSize);
                
                this.player = { x: 1, y: 1 };
                this.goal = { x: this.cols - 2, y: this.rows - 2 };
                this.maze = [];
                this.score = 0;
                this.moves = 0;
                this.startTime = Date.now();
                this.gameWon = false;
                
                // Generar semilla aleatoria √∫nica para cada partida
                this.seed = Date.now() + Math.random() * 1000000;
                
                // Inicializar generador de n√∫meros pseudo-aleatorios
                this.random = this.seededRandom();
                
                // Cargar imagen del personaje Randall
                this.playerImage = new Image();
                this.playerImage.src = 'randall.jpeg';
                this.playerImage.onload = () => {
                    this.generateMaze();
                    this.setupEventListeners();
                    this.gameLoop();
                };
            }
            
            seededRandom() {
                // Generador de n√∫meros pseudo-aleatorios basado en semilla
                let seed = this.seed;
                return function() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                };
            }
            
            generateMaze(attempts = 0) {
                // Evitar bucles infinitos
                if (attempts > 3) {
                    console.warn('Demasiados intentos de generaci√≥n, creando laberinto simple');
                    this.createSimpleMaze();
                    return;
                }
                
                // Inicializar laberinto con paredes
                for (let y = 0; y < this.rows; y++) {
                    this.maze[y] = [];
                    for (let x = 0; x < this.cols; x++) {
                        this.maze[y][x] = 1; // 1 = pared, 0 = camino
                    }
                }
                
                // Asegurar que el inicio y la meta est√©n libres
                this.maze[1][1] = 0;
                this.maze[this.rows - 2][this.cols - 2] = 0;
                
                // Algoritmo de generaci√≥n de laberinto (Recursive Backtracking)
                this.carvePath(1, 1);
                
                // Solo verificar que hay un camino, NO crear uno directo
                if (!this.hasPathToGoal()) {
                    // Si no hay camino, regenerar el laberinto
                    this.generateMaze(attempts + 1);
                    return;
                }
                
                // Verificar que el laberinto sea v√°lido
                if (!this.isValidMaze()) {
                    // Si no es v√°lido, regenerar
                    this.generateMaze(attempts + 1);
                }
            }
            
            carvePath(x, y) {
                this.maze[y][x] = 0;
                
                const directions = [
                    [0, -2], [2, 0], [0, 2], [-2, 0]
                ];
                
                // Mezclar direcciones aleatoriamente con m√°s aleatoriedad
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(this.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                // Agregar aleatoriedad adicional
                if (this.random() < 0.3) {
                    // 30% de probabilidad de cambiar el orden de las direcciones
                    for (let i = 0; i < 2; i++) {
                        const idx1 = Math.floor(this.random() * directions.length);
                        const idx2 = Math.floor(this.random() * directions.length);
                        [directions[idx1], directions[idx2]] = [directions[idx2], directions[idx1]];
                    }
                }
                
                for (let [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (newX > 0 && newX < this.cols - 1 && newY > 0 && newY < this.rows - 1 && this.maze[newY][newX] === 1) {
                        this.maze[y + dy/2][x + dx/2] = 0;
                        this.carvePath(newX, newY);
                    }
                }
            }
            
            hasPathToGoal() {
                // Usar BFS para verificar si hay un camino
                const visited = new Set();
                const queue = [{x: 1, y: 1}];
                visited.add('1,1');
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    if (current.x === this.goal.x && current.y === this.goal.y) {
                        return true;
                    }
                    
                    const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
                    for (let [dx, dy] of directions) {
                        const newX = current.x + dx;
                        const newY = current.y + dy;
                        const key = `${newX},${newY}`;
                        
                        if (newX >= 0 && newX < this.cols && newY >= 0 && newY < this.rows && 
                            this.maze[newY][newX] === 0 && !visited.has(key)) {
                            visited.add(key);
                            queue.push({x: newX, y: newY});
                        }
                    }
                }
                
                return false;
            }
            
            isValidMaze() {
                // Verificar que hay suficientes caminos
                let pathCount = 0;
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        if (this.maze[y][x] === 0) pathCount++;
                    }
                }
                
                // Debe haber al menos un 20% de caminos para ser jugable
                const minPaths = Math.floor((this.rows * this.cols) * 0.2);
                if (pathCount < minPaths) return false;
                
                // Verificar que hay un camino desde el inicio hasta la meta
                return this.hasPathToGoal();
            }
            
            createSimpleMaze() {
                // Crear un laberinto simple pero garantizado
                for (let y = 0; y < this.rows; y++) {
                    this.maze[y] = [];
                    for (let x = 0; x < this.cols; x++) {
                        this.maze[y][x] = 1; // Paredes por defecto
                    }
                }
                
                // Crear un camino en zigzag desde el inicio hasta la meta
                let x = 1, y = 1;
                this.maze[y][x] = 0; // Inicio
                
                // Ir hacia la derecha hasta casi llegar a la meta
                while (x < this.goal.x - 1) {
                    x++;
                    this.maze[y][x] = 0;
                }
                
                // Ir hacia abajo hasta casi llegar a la meta
                while (y < this.goal.y - 1) {
                    y++;
                    this.maze[y][x] = 0;
                }
                
                // Ir hacia la meta
                while (x < this.goal.x) {
                    x++;
                    this.maze[y][x] = 0;
                }
                while (y < this.goal.y) {
                    y++;
                    this.maze[y][x] = 0;
                }
                
                // Agregar algunos caminos adicionales para hacerlo m√°s interesante
                for (let i = 0; i < Math.floor((this.rows * this.cols) * 0.1); i++) {
                    const randomX = Math.floor(this.random() * (this.cols - 2)) + 1;
                    const randomY = Math.floor(this.random() * (this.rows - 2)) + 1;
                    if (this.maze[randomY][randomX] === 1) {
                        this.maze[randomY][randomX] = 0;
                    }
                }
            }
            
            setupEventListeners() {
                // Teclado
                document.addEventListener('keydown', (e) => {
                    if (this.gameWon) return;
                    
                    let newX = this.player.x;
                    let newY = this.player.y;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            newY--;
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            newY++;
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            newX--;
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            newX++;
                            break;
                    }
                    
                    this.movePlayer(newX, newY);
                });
                
                // Mouse/Touch
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameWon) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const cellX = Math.floor(x / this.cellSize);
                    const cellY = Math.floor(y / this.cellSize);
                    
                    this.moveTowards(cellX, cellY);
                });
                
                // Touch para m√≥viles
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.gameWon) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    const cellX = Math.floor(x / this.cellSize);
                    const cellY = Math.floor(y / this.cellSize);
                    
                    this.moveTowards(cellX, cellY);
                });
            }
            
            moveTowards(targetX, targetY) {
                let newX = this.player.x;
                let newY = this.player.y;
                
                if (targetX < this.player.x) newX--;
                else if (targetX > this.player.x) newX++;
                else if (targetY < this.player.y) newY--;
                else if (targetY > this.player.y) newY++;
                
                this.movePlayer(newX, newY);
            }
            
            movePlayer(newX, newY) {
                if (newX >= 0 && newX < this.cols && newY >= 0 && newY < this.rows && this.maze[newY][newX] === 0) {
                    this.player.x = newX;
                    this.player.y = newY;
                    this.moves++;
                    this.updateDisplay();
                    
                    // Verificar victoria
                    if (this.player.x === this.goal.x && this.player.y === this.goal.y) {
                        this.gameWon = true;
                        this.calculateScore();
                        this.showVictory();
                    }
                }
            }
            
            calculateScore() {
                const timeElapsed = (Date.now() - this.startTime) / 1000;
                const timeBonus = Math.max(0, 300 - timeElapsed) * 2; // Bonus por tiempo
                const moveBonus = Math.max(0, 100 - this.moves) * 5; // Bonus por movimientos eficientes
                
                this.score = 100 + Math.floor(timeBonus) + Math.floor(moveBonus);
            }
            
            showVictory() {
                const victoryDiv = document.createElement('div');
                victoryDiv.className = 'victory';
                victoryDiv.innerHTML = `
                    üéâ ¬°VICTORIA! üéâ<br>
                    Puntuaci√≥n: ${this.score}<br>
                    Tiempo: ${this.formatTime((Date.now() - this.startTime) / 1000)}<br>
                    Movimientos: ${this.moves}
                `;
                
                this.canvas.parentNode.insertBefore(victoryDiv, this.canvas.nextSibling);
                
                setTimeout(() => {
                    if (confirm('¬øQuieres jugar otra vez?')) {
                        this.newGame();
                    }
                }, 2000);
            }
            
            updateDisplay() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('moves').textContent = this.moves;
                
                const timeElapsed = (Date.now() - this.startTime) / 1000;
                document.getElementById('time').textContent = this.formatTime(timeElapsed);
                
                // Mostrar la semilla actual
                document.getElementById('current-seed').textContent = this.seed.toString().slice(-6);
            }
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            draw() {
                // Limpiar canvas
                this.ctx.fillStyle = '#f0f0f0';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Dibujar laberinto
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        if (this.maze[y][x] === 1) {
                            this.ctx.fillStyle = '#2c3e50';
                            this.ctx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
                        }
                    }
                }
                
                // Dibujar meta
                this.ctx.fillStyle = '#27ae60';
                this.ctx.fillRect(
                    this.goal.x * this.cellSize + 2, 
                    this.goal.y * this.cellSize + 2, 
                    this.cellSize - 4, 
                    this.cellSize - 4
                );
                
                // Dibujar personaje (imagen Randall)
                if (this.playerImage.complete) {
                    const playerSize = this.cellSize - 2;
                    this.ctx.drawImage(
                        this.playerImage,
                        this.player.x * this.cellSize + 1,
                        this.player.y * this.cellSize + 1,
                        playerSize,
                        playerSize
                    );
                }
            }
            
            gameLoop() {
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            newGame() {
                // Remover mensaje de victoria si existe
                const victoryDiv = document.querySelector('.victory');
                if (victoryDiv) victoryDiv.remove();
                
                // Mostrar indicador de generaci√≥n
                const indicator = document.getElementById('generating-indicator');
                indicator.style.display = 'block';
                
                // Usar setTimeout para permitir que se muestre el indicador
                setTimeout(() => {
                    this.player = { x: 1, y: 1 };
                    this.goal = { x: this.cols - 2, y: this.rows - 2 };
                    this.score = 0;
                    this.moves = 0;
                    this.startTime = Date.now();
                    this.gameWon = false;
                    
                    // Generar nueva semilla para cada partida
                    this.seed = Date.now() + Math.random() * 1000000;
                    this.random = this.seededRandom();
                    
                    this.generateMaze();
                    this.updateDisplay();
                    
                    // Ocultar indicador
                    indicator.style.display = 'none';
                }, 100);
            }
        }
        
        // Funciones globales
        let game;
        
        function newGame() {
            if (game) {
                game.newGame();
            } else {
                game = new MazeGame();
            }
        }
        
        function showInstructions() {
            document.getElementById('instructionsModal').style.display = 'block';
        }
        
        function closeModal() {
            document.getElementById('instructionsModal').style.display = 'none';
        }
        
        // Cerrar modal al hacer click fuera
        window.onclick = function(event) {
            const modal = document.getElementById('instructionsModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }
        
        // Iniciar juego cuando se carga la p√°gina
        window.addEventListener('load', () => {
            game = new MazeGame();
        });
    </script>
</body>
</html>
